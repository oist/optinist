# components = Number of components to keep. if not specified, all components are kept:
# default = None
n_components:


# copy: If False, data passed to fit are overwritten and running fit(X).transform(X) will not yield the expected results, use fit_transform(X) instead.
# default = True
copy: True


# whiten: When True (False by default) the components_ vectors are multiplied by the
#  square root of n_samples and then divided by the singular values to ensure uncorrelated
#  outputs with unit component-wise variances.
# Whitening will remove some information from the transformed signal
#  (the relative variance scales of the components) but can sometime improve
#  the predictive accuracy of the downstream estimators by making their data respect
#  some hard-wired assumptions.
# default: False
whiten: False


# svd_solver{‘auto’, ‘full’, ‘arpack’, ‘randomized’},
# If auto : The solver is selected by a default policy based on X.shape and n_components.
#  if the input data is larger than 500x500 and the number of components to extract is lower than 80% of the smallest dimension of the data, then the more efficient ‘randomized’ method is enabled. Otherwise the exact full SVD is computed and optionally truncated afterwards.
#
# If full :
# run exact full SVD calling the standard LAPACK solver via scipy.linalg.svd and select the components
# by postprocessing
#
# If arpack :
# run SVD truncated to n_components calling ARPACK solver via scipy.sparse.linalg.svds.
# It requires strictly 0 < n_components < min(X.shape)
#
# If randomized :
# run randomized SVD by the method of Halko et al.
#default=’auto’
svd_solver: 'auto'



# tol: Tolerance for singular values computed by svd_solver == ‘arpack’. Must be of range [0.0, infinity).
# default=0:
tol: 0.0


# iterated_power(int or ‘auto’): Number of iterations for the power method computed by svd_solver == ‘randomized’.
#  Must be of range [0, infinity).
# default = 'auto'
iterated_power: 'auto'

# random_state(int, RandomState instance or None):Used when the ‘arpack’ or ‘randomized’ solvers are used.
# Pass an int for reproducible results across multiple function calls.
# default = None
random_state:


# whether standardize the data or not
standardization_mean: True
standardization_std: True